---
title: "Tidy Tuesday 11/24/2020 Washington Trails"
author: "greg dubrow"
date: "11/24/2020"
output: md_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "images/",
  out.width = "100%") 
```

```{r pkg load, message=FALSE, ECHO = FALSE}
# readin in data, create df for plots
library(tidytuesdayR) # to load tidytuesday data
library(tidyverse) # to do tidyverse things
library(tidylog) # to get a log of what's happening to the data
library(patchwork) # stitch plots together
library(gt) # lets make tables
library(RColorBrewer) # colors!
library(scales) # format chart output
```

### First let's read in the file using the tidytuesdayR package. We'll also look at the raw data
```{r echo = FALSE, message=FALSE}
tt_watrail <- tt_load("2020-11-24")

glimpse(tt_watrail$hike_data)
```

### There are a few things we want to do with the data for the working dataframe: 
  * create columns for miles, direction, type from length
  * create specific location columns frolm location
  * change rating, gain and highpoint to numeric
  * create a rating group
  * separate out features and make the resulting df long. we'll use distinct when we only need 1 obs per trail

```{r echo = FALSE}
tt_watraildf <- tt_watrail$hike_data %>%
  mutate(length_miles = parse_number(length)) %>%
  mutate(across(gain:rating, as.numeric)) %>%
  mutate(rating_grp = case_when(rating == 0 ~ "0",
                                rating >0 & rating < 2 ~ "1",
                                rating >=2 & rating < 3 ~ "2",
                                rating >=3 & rating < 4 ~ "3",
                                rating >=4 & rating < 5 ~ "4",
                                rating == 5 ~ "5")) %>%
  mutate(trail_type = case_when(grepl("roundtrip", length) ~ "Round trip",
                          grepl("one-way", length) ~ "One Way",
                          grepl("of trails", length) ~ "Trails")) %>% 
  mutate(location_split = location) %>%
  separate(location_split, c("location_region","location_specific"), sep = ' -- ') %>%
  unnest(cols = c(features)) %>% 
  mutate(feature_init = case_when(features == "Dogs allowed on leash" ~ "DA",
                                  features == "Dogs not allowed" ~ "DN",
                                  features == "Wildlife" ~ "Wl",
                                  features == "Good for kids" ~ "GK",
                                  features == "Lakes" ~ "Lk",
                                  features == "Fall foliage" ~ "FF",
                                  features == "Ridges/passes" ~ "RP",
                                  features == "Established campsites" ~ "EC",
                                  features == "Mountain views" ~ "MV",
                                  features == "Old growth" ~ "OG",
                                  features == "Waterfalls" ~ "Wf",
                                  features == "Wildflowers/Meadows" ~ "WM",
                                  features == "Rivers" ~ "Ri",
                                  features == "Coast" ~ "Co",
                                  features == "Summits" ~ "Su")) %>%
  mutate(feature_type = if_else(feature_init %in% c("DA","DN","GK"), "Companion", "Feature")) %>%
  select(name, location_region, location_specific, trail_type, length_miles, 
         gain, highpoint, rating, rating_grp, features, feature_init, feature_type, description, location, length)

```

### To get a sense of what the data look like, I'll run some historgrams and scatterplots to see how things cluster, if there are outliers or anything else especially noticable.
Using log10 for the length scale to even out the spread. [Patchwork](https://patchwork.data-imaginist.com/) stitches the plots together in a neat panel.
```{r fig.width=7.5, fig.height=4.0, dpi = 300, echo = FALSE, warning=FALSE, message = FALSE, error= FALSE }
hist_length <-
tt_watraildf %>%
  distinct(name, .keep_all = TRUE) %>%
  ggplot(aes(length_miles)) +
  geom_histogram(alpha = 0.8) +
  scale_x_log10() +
  labs(x = "Length (miles), log10")

hist_gain <-
  tt_watraildf %>%
  distinct(name, .keep_all = TRUE) %>%
  ggplot(aes(gain)) +
  geom_histogram(alpha = 0.8) +
  scale_x_log10()

hist_high <-
  tt_watraildf %>%
  distinct(name, .keep_all = TRUE) %>%
  ggplot(aes(highpoint)) +
  geom_histogram(alpha = 0.8) 

hist_rate <-
  tt_watraildf %>%
  distinct(name, .keep_all = TRUE) %>%
  ggplot(aes(rating)) +
  geom_histogram(alpha = 0.8) 

(hist_length | hist_gain) /
  (hist_high | hist_rate)
```
For the scatterplots, I plotted length by gain, faceting by ratings groups and then by region. We do have to be careful with ratings, as they are user-generated and some trails have very few votes. Log10 used again for length.
```{r fig.width=7.5, fig.height=4.0, dpi = 300, echo = FALSE, warning=FALSE, message = FALSE, error= FALSE }

tt_watraildf %>%
  distinct(name, .keep_all = TRUE) %>%
  ggplot(aes(length_miles, gain)) +
  geom_point() +
  geom_smooth() +
  scale_x_log10() +
  labs(x = "Length (miles) log10", y = "Total Gain",
       title = "Length v Gain, by Rating Group") +
  facet_wrap(vars(rating_grp))

tt_watraildf %>%
  distinct(name, .keep_all = TRUE) %>%
  ggplot(aes(length_miles, gain)) +
  geom_point() +
  geom_smooth() +
  scale_x_log10() +
  labs(x = "Length (miles) log 10", y = "Total Gain",
       title = "Length v Gain, by Region") +
  facet_wrap(vars(location_region))

```

The outliers in terms of gain & length clustered in a few regions, so I wanted to see which they were. Not a surprise they clustered in the Cascades & Rainier.
```{r echo = FALSE, warning=FALSE, message = FALSE, error= FALSE}
tt_watraildf %>%
  distinct(name, .keep_all = TRUE) %>%
  filter(gain > 15000) %>%
  filter(length_miles > 90) %>%
  select(location_region, name, length_miles, gain) %>%
  arrange(name) 

```

### Now that we see how the length, gain, highpoint & ratings spread out, I want build a table to see the averages by region. 

I've been wanting to take a deeper dive into [gt](https://gt.rstudio.com/) & [reactable](https://glin.github.io/reactable/). Since I'm doing this as a markdown doc & not HTML, I'll output using gt here. I've got some basic gt calls down, this excercise is all about conditionally formatting columns based on value. So inspired by [Thomas Mock's gt primer](https://themockup.blog/posts/2020-05-16-gt-a-grammer-of-tables), a basic table with heatmap-like formatting for some columns. See his explainer for details on the code, and for more features than I'm including.
```{r fig.width=7.5, fig.height=4.0, dpi = 300, echo = FALSE, warning=FALSE, message = FALSE, error= FALSE }
# create by region averages df
byregion <-  tt_watraildf %>%
  distinct(name, .keep_all = TRUE) %>%
  group_by(location_region) %>%
  summarise(n_region = n(),
            avglength = mean(length_miles),
            avgrating = mean(rating),
            avggain = mean(gain),
            avghigh = mean(highpoint),
            minhigh = min(highpoint),
            maxhigh = max(highpoint)) %>%
  mutate_at(vars(avglength:avgrating), round, 2) %>%
  mutate_at(vars(avggain:avghigh), round, 0) 

# create table - code commented out so html doesn't show up in md output. 
# image saved from tt_20201124_watrails.r code
# byregion %>%
#   gt() %>%
#   fmt_number(columns = vars(avggain, avghigh, minhigh, maxhigh), decimals = 0, use_seps = TRUE) %>%
  # sets the columns and palette to format cell color by value range
  # data_color(
  #   columns = vars(avglength, avgrating, avggain, avghigh, minhigh, maxhigh),
  #   colors = scales::col_numeric(
  #     palette = c("#ffffff", "#f2fbd2", "#c9ecb4", "#93d3ab", "#35b0ab"),
  #     domain = NULL)) %>%
  # tab_style calls add border boxes first to column labels, then body cells
  # tab_style(
  #   style = list(
  #     cell_borders(
  #       sides = "all", color = "grey", weight = px(1))),
  #   locations = list(
  #     cells_column_labels(
  #       columns = gt::everything()
  #       ))) %>%
  # tab_style(
  #   style = list(
  #     cell_borders(
  #       sides = "all", color = "grey", weight = px(1))),
  #   locations = list(
  #     cells_body(
  #       rows = gt::everything()
  #     ))) %>%
  #   cols_align(columns = TRUE, align = "center") %>%
  # cols_align(columns = "location_region", align = "left") %>%
  # tab_header(title = "Regional Averages",
  #            subtitle = md("_North Cascades have longest trails, 
  #                          all mountain areas have lots of gain and highest points_")) %>%
#  cols_label(location_region = "Region", n_region = "N", avglength = "Avg Length (miles)",
#            avgrating = "Avg Rating", avggain = "Avg Gain (ft)",avghigh = "Avg Highpoint",
#             minhigh = "Lowest high point", maxhigh = "Max high point")
```
![](images/tt11242020_gtavgbyregion.png)

### And finally a couple of models to see what might affect a trail rating.

First a simple linear model using length, gain, & highpoint to predict rating
```{r echo = FALSE, warning=FALSE, message = FALSE, error= FALSE }

# creat df with distinct observations for each trail 
tt_watraildf_dist <- tt_watraildf %>%
  distinct(name, .keep_all = TRUE)

# run the regression, see the stats
wtmodel1 <- lm(rating ~ length_miles + gain + highpoint, data = tt_watraildf_dist)
summary(wtmodel1)
```
